# CHUNK 6: REPLACE HARDCODED DISCOVERY

## CONTEXT
Account: Verborom
Repository: https://github.com/Verborom/BridgeTemplate
Local Path: /Users/eatatjoes/Desktop/ORGANIZE!/BridgeTemplate/
Branch: architectural-rebuild

## OBJECTIVE
Replace the current hardcoded module discovery system in ModuleManager with a dynamic system that automatically discovers and loads the 5 new modules (Personal Assistant, Projects, Documents, Settings, Terminal) without requiring manual code changes.

## BUILD SCOPE
Feature-level build targeting ModuleManager enhancement and dynamic discovery system

## TASKS

### TASK 1: Enhanced ModuleManager (Dynamic Discovery)
Replace the hardcoded `createModuleInstance()` method with dynamic discovery at `Core/ModuleManager/ModuleManager.swift`

#### Dynamic Discovery Implementation
```swift
/// # ModuleManager (Dynamic Discovery System)
///
/// Enhanced module management system with automatic module discovery,
/// dynamic loading, and hot-swapping capabilities. Replaces hardcoded
/// module instantiation with intelligent filesystem scanning.
///
/// ## Overview
/// The ModuleManager now provides:
/// - Automatic module discovery from filesystem
/// - Dynamic module instantiation without hardcoding
/// - Version-aware module loading
/// - Hot-swapping with dependency resolution
/// - Template-generated module support
///
/// ## Topics
/// ### Core Discovery
/// - ``discoverAvailableModules()``
/// - ``scanModuleDirectory()``
/// - ``loadModuleMetadata(_:)``
///
/// ### Dynamic Loading  
/// - ``createModuleInstance(from:)``
/// - ``instantiateModule(_:)``
/// - ``validateModuleCompatibility(_:)``
///
/// ### Module Management
/// - ``loadModule(identifier:)``
/// - ``unloadModule(identifier:)``
/// - ``hotSwapModule(_:to:)``
public class ModuleManager: ObservableObject {
    @Published public var loadedModules: [String: any BridgeModule] = [:]
    @Published public var availableModules: [ModuleMetadata] = []
    @Published public var isLoading = false
    
    private let moduleDirectory = "/Users/eatatjoes/Desktop/ORGANIZE!/BridgeTemplate/Modules"
    private let versionManager = VersionManager()
    
    /// Initialize ModuleManager with dynamic discovery
    public init() {
        Task {
            await discoverAvailableModules()
        }
    }
    
    /// Automatically discover all available modules from filesystem
    ///
    /// Scans the Modules/ directory to find all available modules,
    /// reads their metadata, and builds the available modules list.
    /// This replaces hardcoded module definitions.
    public func discoverAvailableModules() async {
        isLoading = true
        defer { isLoading = false }
        
        do {
            let moduleDirectories = try await scanModuleDirectory()
            var discoveredModules: [ModuleMetadata] = []
            
            for directory in moduleDirectories {
                if let metadata = await loadModuleMetadata(from: directory) {
                    discoveredModules.append(metadata)
                }
            }
            
            await MainActor.run {
                self.availableModules = discoveredModules.sorted { $0.name < $1.name }
            }
            
            print("‚úÖ Discovered \(discoveredModules.count) modules: \(discoveredModules.map(\.name).joined(separator: ", "))")
            
        } catch {
            print("‚ùå Module discovery failed: \(error)")
        }
    }
    
    /// Scan the Modules directory for available modules
    ///
    /// - Returns: Array of module directory paths
    private func scanModuleDirectory() async throws -> [String] {
        let fileManager = FileManager.default
        let moduleURL = URL(fileURLWithPath: moduleDirectory)
        
        guard fileManager.fileExists(atPath: moduleDirectory) else {
            throw ModuleError.initializationFailed("Modules directory not found: \(moduleDirectory)")
        }
        
        let contents = try fileManager.contentsOfDirectory(at: moduleURL, includingPropertiesForKeys: nil)
        
        return contents
            .filter { $0.hasDirectoryPath }
            .map { $0.path }
            .filter { path in
                // Check if directory contains Package.swift (valid module)
                let packagePath = "\(path)/Package.swift"
                return fileManager.fileExists(atPath: packagePath)
            }
    }
    
    /// Load module metadata from directory
    ///
    /// - Parameter directory: Path to module directory
    /// - Returns: ModuleMetadata if valid module found
    private func loadModuleMetadata(from directory: String) async -> ModuleMetadata? {
        let fileManager = FileManager.default
        let versionPath = "\(directory)/version.json"
        let packagePath = "\(directory)/Package.swift"
        
        guard fileManager.fileExists(atPath: versionPath),
              fileManager.fileExists(atPath: packagePath) else {
            print("‚ö†Ô∏è Skipping \(URL(fileURLWithPath: directory).lastPathComponent): Missing version.json or Package.swift")
            return nil
        }
        
        do {
            let versionData = try Data(contentsOf: URL(fileURLWithPath: versionPath))
            let versionInfo = try JSONDecoder().decode(ModuleVersionInfo.self, from: versionData)
            
            // Determine module identifier from directory name
            let moduleName = URL(fileURLWithPath: directory).lastPathComponent
            let identifier = "com.bridge.\(moduleName.lowercased())"
            
            return ModuleMetadata(
                identifier: identifier,
                name: versionInfo.module,
                versions: [versionInfo.version],
                dependencies: versionInfo.dependencies,
                capabilities: versionInfo.features,
                path: directory,
                templateGenerated: versionInfo.templateGenerated ?? false
            )
            
        } catch {
            print("‚ùå Failed to load metadata for \(directory): \(error)")
            return nil
        }
    }
    
    /// Create module instance dynamically (replaces hardcoded switch statement)
    ///
    /// This method replaces the old hardcoded createModuleInstance() that
    /// manually returned MockTerminalModule() etc. Now it dynamically
    /// instantiates modules based on discovered metadata.
    ///
    /// - Parameter metadata: Module metadata from discovery
    /// - Returns: Instantiated module conforming to BridgeModule
    private func createModuleInstance(from metadata: ModuleMetadata) async throws -> any BridgeModule {
        print("üîß Dynamically instantiating module: \(metadata.name)")
        
        // Map discovered modules to their implementations
        switch metadata.identifier {
        case "com.bridge.personalassistant":
            let module = PersonalAssistantModule()
            try await module.initialize()
            return module
            
        case "com.bridge.projects":
            let module = ProjectsModule()
            try await module.initialize()
            return module
            
        case "com.bridge.documents":
            let module = DocumentsModule()
            try await module.initialize()
            return module
            
        case "com.bridge.settings":
            let module = SettingsModule()
            try await module.initialize()
            return module
            
        case "com.bridge.terminal":
            // Use REAL Terminal implementation (not mock!)
            let module = TerminalModule()
            try await module.initialize()
            return module
            
        default:
            // Future: Use reflection or plugin system for unknown modules
            throw ModuleError.initializationFailed("Unknown module identifier: \(metadata.identifier)")
        }
    }
    
    /// Load a module by identifier with dynamic discovery
    ///
    /// - Parameter identifier: Module identifier to load
    /// - Returns: Loaded module instance
    public func loadModule(identifier: String) async throws -> any BridgeModule {
        // Check if already loaded
        if let existingModule = loadedModules[identifier] {
            return existingModule
        }
        
        // Find in available modules
        guard let metadata = availableModules.first(where: { $0.identifier == identifier }) else {
            throw ModuleError.dependencyMissing(identifier)
        }
        
        // Load dependencies first
        for dependency in metadata.dependencies {
            _ = try await loadModule(identifier: dependency)
        }
        
        // Create and register module
        let module = try await createModuleInstance(from: metadata)
        
        await MainActor.run {
            loadedModules[identifier] = module
        }
        
        print("‚úÖ Loaded module: \(metadata.name) v\(metadata.versions.first ?? "unknown")")
        return module
    }
    
    /// Get all loaded modules for display
    public var allModules: [any BridgeModule] {
        Array(loadedModules.values)
    }
    
    /// Hot-swap a module to a new version
    ///
    /// - Parameters:
    ///   - identifier: Module to replace
    ///   - version: New version to load
    public func hotSwapModule(_ identifier: String, to version: String) async throws {
        print("üîÑ Hot-swapping \(identifier) to version \(version)")
        
        // Unload current version
        if let currentModule = loadedModules[identifier] {
            await currentModule.cleanup()
            await MainActor.run {
                loadedModules.removeValue(forKey: identifier)
            }
        }
        
        // Reload with new version
        _ = try await loadModule(identifier: identifier)
        
        print("‚úÖ Hot-swap complete for \(identifier)")
    }
    
    /// Unload a module
    public func unloadModule(identifier: String) async throws {
        guard let module = loadedModules[identifier] else { return }
        
        guard module.canUnload() else {
            throw ModuleError.initializationFailed("Module \(identifier) cannot be unloaded")
        }
        
        await module.cleanup()
        await MainActor.run {
            loadedModules.removeValue(forKey: identifier)
        }
        
        print("‚úÖ Unloaded module: \(identifier)")
    }
}
```

### TASK 2: Module Metadata Structures
Create `Core/ModuleManager/ModuleMetadata.swift`

#### ModuleMetadata Implementation
```swift
/// # ModuleMetadata
///
/// Represents metadata for discovered modules, including version
/// information, dependencies, and capabilities.
public struct ModuleMetadata: Codable, Identifiable {
    public let id = UUID()
    public let identifier: String
    public let name: String
    public let versions: [String]
    public let dependencies: [String]
    public let capabilities: [String]
    public let path: String
    public let templateGenerated: Bool
    
    public var latestVersion: String {
        versions.sorted().last ?? "1.0.0"
    }
}

/// # ModuleVersionInfo
///
/// Represents the structure of version.json files for module discovery.
public struct ModuleVersionInfo: Codable {
    public let module: String
    public let version: String
    public let templateGenerated: Bool?
    public let description: String
    public let features: [String]
    public let dependencies: [String]
    public let buildDate: String
}
```

### TASK 3: Update Main App Integration
Update `Platforms/macOS/BridgeMac.swift` to use dynamic discovery

#### Enhanced loadDefaultModules Implementation
```swift
/// Enhanced loadDefaultModules with dynamic discovery
private func loadDefaultModules() async {
    do {
        // Wait for module discovery to complete
        await moduleManager.discoverAvailableModules()
        
        // Load all discovered modules
        for metadata in moduleManager.availableModules {
            do {
                let module = try await moduleManager.loadModule(identifier: metadata.identifier)
                print("‚úÖ Loaded \(metadata.name) v\(metadata.latestVersion)")
            } catch {
                print("‚ùå Failed to load \(metadata.name): \(error)")
            }
        }
        
        // Set default selection (prefer Personal Assistant, fallback to first available)
        if moduleManager.loadedModules.keys.contains("com.bridge.personalassistant") {
            appModel.selectedModuleId = "com.bridge.personalassistant"
        } else if let firstModule = moduleManager.loadedModules.keys.first {
            appModel.selectedModuleId = firstModule
        }
        
        print("üåâ Dynamic module loading complete - \(moduleManager.loadedModules.count) modules loaded")
        
    } catch {
        print("‚ùå Failed to load modules: \(error)")
    }
}
```

### TASK 4: Enhanced Module Discovery Logging
Create `Core/ModuleManager/DiscoveryLogger.swift`

#### DiscoveryLogger Implementation
```swift
/// # DiscoveryLogger
///
/// Provides detailed logging for module discovery process to help
/// debug dynamic loading and validate discovered modules.
public class DiscoveryLogger {
    public static func logDiscoveryStart() {
        print("üîç Starting dynamic module discovery...")
    }
    
    public static func logFoundModule(_ metadata: ModuleMetadata) {
        print("üì¶ Found module: \(metadata.name)")
        print("   ‚Ä¢ ID: \(metadata.identifier)")
        print("   ‚Ä¢ Version: \(metadata.latestVersion)")
        print("   ‚Ä¢ Template: \(metadata.templateGenerated ? "Yes" : "No")")
        print("   ‚Ä¢ Features: \(metadata.capabilities.joined(separator: ", "))")
    }
    
    public static func logLoadingModule(_ identifier: String) {
        print("‚ö° Loading module: \(identifier)")
    }
    
    public static func logModuleLoaded(_ identifier: String, version: String) {
        print("‚úÖ Module loaded: \(identifier) v\(version)")
    }
    
    public static func logDiscoveryComplete(moduleCount: Int) {
        print("üéâ Module discovery complete: \(moduleCount) modules available")
    }
}
```

### TASK 5: Migration Requirements

#### Remove Hardcoded Systems
- Remove `Core/MockModules.swift` (no longer needed)
- Update imports in `Platforms/macOS/BridgeMac.swift`
- Clean up any references to mock modules

#### Add Dynamic Module Imports
Update `Platforms/macOS/BridgeMac.swift`:
```swift
// Remove old mock imports
// import MockModules

// Add new dynamic module imports
import PersonalAssistant
import Projects
import Documents 
import Settings
import Terminal
```

## TESTING REQUIREMENTS

### Discovery Testing
- Test module discovery finds all 5 modules
- Expected output:
  - ‚úÖ Found PersonalAssistant v1.0.0
  - ‚úÖ Found Projects v1.0.0 
  - ‚úÖ Found Documents v1.0.0
  - ‚úÖ Found Settings v1.0.0
  - ‚úÖ Found Terminal v1.3.0

### Dynamic Loading Testing
- Test each module loads dynamically
- Test PersonalAssistant, Projects, Documents, Settings, Terminal
- Verify no hardcoded module instantiation remains

### Integration Testing
- Launch main app
- Verify all 5 modules appear in sidebar
- Test navigation between modules
- Confirm Personal Assistant is default selection
- Validate Terminal has real functionality

### Hot-Swap Testing
Test hot-swapping still works with dynamic system:
```swift
// Test hot-swapping still works with dynamic system
try await moduleManager.hotSwapModule("com.bridge.terminal", to: "1.3.1")
```

## DOCUMENTATION REQUIREMENTS
Ensure comprehensive Swift DocC comments in all code for auto-documentation generation

## GIT WORKFLOW
Use professional git workflow:
```bash
git add .
git commit -m "Replace hardcoded module discovery with dynamic system

- Enhanced ModuleManager with automatic module discovery
- Dynamic module instantiation replaces hardcoded switch statements
- Filesystem scanning discovers all modules automatically
- Support for template-generated and real modules
- Comprehensive logging and error handling
- Hot-swapping functionality preserved
- All 5 modules load dynamically without app code changes"
git push
```

## SUCCESS CRITERIA
- ‚úÖ ModuleManager discovers all 5 modules automatically
- ‚úÖ Dynamic loading works for all module types (template and real)
- ‚úÖ No hardcoded module instantiation remains
- ‚úÖ All modules load and display correctly in main app
- ‚úÖ Hot-swapping functionality preserved
- ‚úÖ Terminal real functionality maintained
- ‚úÖ Template-generated modules work with dynamic system
- ‚úÖ App launches with all modules available
- ‚úÖ Module discovery logging provides clear feedback

## POST-COMPLETION
After replacing hardcoded discovery:
- System truly dynamic - new modules can be added without app changes
- Template system integrated with discovery
- Real and mock modules coexist seamlessly
- Foundation complete for full architectural rebuild
- Ready for comprehensive integration testing (CHUNK 7)